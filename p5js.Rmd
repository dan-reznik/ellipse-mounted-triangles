---
title: "R Notebook"
output: html_document
---

```{r}
library(tidyverse)
```

```{r}
lines <- read_lines("data/x0001_0200 cform v1.txt"
                    #,n_max=10
                    ) %>%
  head(-1)
lines %>% head
```

```{r}
lines[132]
```


```{r}
lines_clean <- lines %>%
  str_replace(fixed('", '),'";') %>%
  str_replace(fixed(', "'),';"') %>%
  str_remove("^\\{") %>%
  str_remove("\\},?$") %>%
  str_replace(fixed("List("),"[") %>%
  str_replace(fixed(');"'),'];"')%>%
  str_remove_all(fixed('\"')) %>%
  str_replace_all(" ([+-]) ","\\1") %>%
  str_replace_all(fixed(", "),",") %>%
  str_replace_all(fixed("Power"),"Math.pow") # %>%
  # iverton: precisamos que o separador entre trilineares seja o |
  # para nao conflitar com a virgula do Math.pow
  # 1) regex troca o separador do math.pow p/ & 
  # 2) regex troca virgulas por |
  # 3) regex troca o & de volta pra virgula
  
lines_clean %>% head
```

```{r}
lines_clean[132]
```

Salva csv

```{r}
c("kimberling;trilins;name",
  lines_clean) %>% write_lines("data/x0001_0200 formulas.csv")
```


```{r}
df_formulas <- read_csv2("data/x0001_0200 formulas.csv",col_types = "ccc")
df_formulas %>% glimpse
```

```{r}
df_formulas[132,]
```


Cria dicionario key-value

```{r}
vars_db <- read_lines("data/vars_db.txt") %>%
  str_split(fixed(" = "))
vars_dict <- new.env()
vars_db %>% walk(~assign(.x[1], .x[2], envir = vars_dict))
```

```{r}
get("b2",env=vars_dict)
```

[not used yet] Cria tibble key-value

```{r}
df_vars_db <- read_delim("data/vars_db.txt",
           delim=fixed("="),
           col_types = "cc",
           col_names=c("lhs","rhs"))
```

# Iverton: trazer alem dos lookups as dependencias no bloco de variaveis 

```{r utils}
strip_first_last <- function(s) s%>%str_sub(start=2)%>%str_sub(end=-2)
# n: 131
# triple: [
#    secA*(-(S*sec2A)+sumT2)*(-((sec2B+sec2C)*sumS2)+2*sumT2),
#    secB*(-(S*sec2B)+sumT2)*(-((sec2A+sec2C)*sumS2)+2*sumT2),
#    secC*(-(S*sec2C)+sumT2)*(-((sec2A+sec2B)*sumS2)+2*sumT2)
#         ]
# vars:  c("secA","S","sec2A","sumT2","sec2B","sec2C","sumS2","secB","secC") 
my_js <- function(n,trilins,vars) {
  # iverton mudar abaixio o separador das trilineares p/ "|"
  s3 <- str_split(trilins%>%strip_first_last,fixed(",")) # fixed("|")
  vars_block <- vars %>% map_chr(~str_c("   let ",.x,"=",
                                        get(.x,env=vars_dict),";")) %>%
    str_c(collapse="\n")
  s3 %>% map_chr(~str_glue(
    "function trilin_X{n}(orbit, [a, b, c]) {{",
    # inserir bloco de variaveis usando vars_dict ou inner_join
    "   /* begin vars */",
    "{vars_block}",
    "   /* end vars */",
    "   let v1 = {.x[1]};",
    "   let v2 = {.x[2]};",
    "   let v3 = {.x[3]};",
    "   tris = [v1,v2,v3];",
    "   return trilin_to_cartesian(orbit, [a, b, c], tris);",
    "}}",
    .sep="\n"))
}
```

```{r}
delete_me <- function(x) {(x%in%c("","Math","pow","a","b","c"))|(str_detect(x,"^[:digit:]$"))}

df_formulas_vars <- df_formulas %>%
  mutate(vars=trilins %>%
           strip_first_last %>% # remove colchetes [ ... ]
           str_split("[^[:alnum:]]") %>% # split por nao-alfanums (+,-,/)
           map(~discard(.x,delete_me)) %>% # remove indesejaveis
           map(unique)) # so reporta unicos
```


```{r}
xn <- 132
my_js(
  xn,
  df_formulas_vars$trilins[xn],
  df_formulas_vars$vars[[xn]]) %>% cat
```

{% raw %}
```{r}
df_forumulas %>%
  mutate(js=my_js())
```
{% endraw %}


```{js,eval=F}
function trilin_X{k}(orbit, [a, b, c]) {
  { preamble set vars }
  let v1 = a*(b2+c2-a2);
  let v2 = b*(c2+a2-b2);
  let v3 = c*(a2+b2-c2)
  tris = [v1,v2,v3];
  return trilin_to_cartesian(orbit, [a, b, c], tris);
}

function trilin_cyclic(orbit, fn, [a, b, c]) {
  tris = [fn(a, b, c), fn(b, c, a), fn(c, a, b)];
  return trilin_to_cartesian(orbit, [a, b, c], tris);
}

function trilin_X3(orbit, [a, b, c]) {
  let cyclic = function(a, b, c) {
    let a2 = a * a,
      b2 = b * b,
      c2 = c * c;
    return a * (b2 + c2 - a2);
  }
  return trilin_cyclic(orbit, cyclic, [a, b, c]);
}



```
